# 알고리즘 특강

> 우재남 강사(2022.01.11 ~ 2022.01.12)

## 자료구조

- 선형

  - 선형 리스트 : 배열

    - 삽입/삭제에서 오버헤드 생길 수 있음
    - 접근속도 빠름
    - 시계열 데이터(시간 순서로 생성. 삽입/삭제 x)

    ```python
    ## 함수 선언부
    def add_data(friend):
        katok.append(None)      # 빈칸 추가
        idx = len(katok) - 1
        katok[idx] = friend
    
    def insert_data(pos, friend):
        katok.append(None)
        idx = len(katok) - 1
        for i in range(idx, pos, -1):
            katok[i] = katok[i-1]
            katok[i-1] = None
        katok[pos] = friend
    
    def delete_data(pos):
        katok[pos] = None
        idx = len(katok)
        for i in range(pos+1, idx, 1):
            katok[i-1] = katok[i]
            katok[i] = None
        del katok[idx-1]
            
    
    ## 전역 변수부
    katok = []
    select = -1
    
    ## 메인 코드부
    if __name__ == '__main__':
        while select != 4:
            select = int(input('선택하세요(1: 추가, 2: 삽입, 3: 삭제, 4: 종료) : '))
    
            if select == 1:
                data = input('추가할 데이터 : ')
                add_data(data)
                print(katok)
            elif select == 2:
                pos = int(input('삽입할 위치 : '))
                data = input('추가할 데이터 : ')
                insert_data(pos, data)
                print(katok)
            elif select == 3:
                pos = int(input('삭제할 위치 : '))
                delete_data(pos)
                print(katok)
            elif select == 4:
                print(katok)
                break
            else:
                print('1~4 중 하나를 입력하세요')
                continue
    ```

  - 단순 연결리스트

    - 노드들이 물리적으로 떨어진 곳에 위치

    - 각 노드의 번지도 순차적이지 않음

    - 화살표로 표시된 연결(링크)을 따라가면 선형 리스트 순서와 같음

    - 데이터를 삽입/삭제할 때

      - 선형 리스트는 많은 작업이 필요(오버헤드 발생)
      - 단순 연결 리스트는 해당 노드의 앞뒤 링크만 수정하면 되므로 오버헤드가 거의 발생하지 않음

    - 노드 구조

      - 단순 연결리스트는 다음 데이터를 가리키는 링크가 필요

      - 노드는 데이터와 링크로 구성

        ![image](https://user-images.githubusercontent.com/87686562/148880412-cc3dd9f9-f27e-4907-a2bf-38d33ee08628.png)

        ```python
        # 함수
        class Node():
            def __init__(self):
                self.data = None
                self.link = None
        
        def printNodes(start):
            current = start
            print(current.data, end = ' ')
            while current.link != None:
                current = current.link
                print(current.data, end = ' ')
            print()
        
        def insert(findData, insertData):
            global memory, head, current, pre
            node = Node()
            node.data = insertData
            # 첫 노드 앞에 삽입
            if findData == head.data:
                node.link = head
                head = node
                memory.append(node)
                return
            # 중간에 삽입
            current = head
            while current.link != None:
                pre = current
                current = current.link
                if current.data == findData:
                    pre.link = node
                    node.link = current
                    memory.append(node)
                    return
            # 마지막에 삽입
            current.link = node
            memory.append(node)
            return
        
        def delete(deleteData):
            global memory, head, current, pre
            # 첫 노드 삭제
            if deleteData == head.data:
                memory.remove(current)
                current = head
                head = head.link
                return
            # 두 번째 이후 삭제
            current = head
            while current.link != None:
                pre = current
                current = current.link
                if current.data == deleteData:
                    memory.remove(current)
                    pre.link = current.link
                    return
        
        def findNode(findData):
            global memory, head, current, pre
            current = head
            if current.data == findData:
                return current              # Node를 통째로 return
            while current.link != None:
                current = current.link
                if current == findData:
                    return current
            return Node()
        
        # 전역
        memory = []
        head, current, pre = None, None, None
        dataArray = ['다현', '정연', '쯔위', '사나', '지효']
        
        # 메인
        node = Node()
        node.data = dataArray[0]
        head = node
        memory.append(node)
        for data in dataArray[1:]:
            pre = node
            node = Node()
            node.data = data
            pre.link = node
            memory.append(node)
        insert('다현', '유현')
        printNodes(head)
        insert('사나', '세경')
        printNodes(head)
        insert('바보', '소현')
        printNodes(head)
        delete('유현')
        printNodes(head)
        delete('쯔위')
        printNodes(head)
        fNode = findNode('쯔위')
        print(fNode.data)
        ```

  - 원형 연결 리스트

  - 스택 ⭐⭐⭐

    - 먼저 들어간 것이 가장 나중에 나오는 구조(FILO)

      ```python
      # 함수
      def isFull():
          """ 스택이 꽉 찼는가? """
          if top >= SIZE - 1:
              return True
          return False
      
      def push(data):
          global top
          if isFull():
              print('Stack is Full')
              return None
          top += 1
          stack[top] = data
      
      def isEmpty():
          global top
          if top == -1:
              return True
          return False
      
      def pop():
          global top
          if isEmpty():
              print('Stack is Empty')
              return None
          data = stack[top]
          stack[top] = None
          top -= 1
          return data
      
      def peek():
          global top
          if isEmpty():
              print('Stack is Empty')
              return None
          return stack[top]
      
      # 전역
      SIZE = 5
      # stack = [None for _ in range(SIZE)]
      stack = [None] * SIZE
      top = -1
      
      # 메인
      push('커피1')
      push('커피2')
      print(peek())
      print(isFull())
      retdata = pop()
      print('pop :', retdata)
      retdata = pop()
      print('pop :', retdata)
      retdata = pop()
      print('pop :', retdata)
      print(isEmpty())
      ```

  - 일반 큐

    - First In First Out
    - 삽입(enqueue), 추출(dequeue), 첫 번째 데이터(front), 마지막 데이터(rear)

  - 원형 큐

- 비선형

  - 트리 : 이진 탐색 트리 ⭐⭐⭐
  - 그래프 : 개념 + 인접행렬

## 알고리즘

- 정렬 : 선택 정렬 ⭐⭐⭐
- 검색 : 순차 검색, 이진 검색 => O(log n)
- 재귀 : 직접 실습