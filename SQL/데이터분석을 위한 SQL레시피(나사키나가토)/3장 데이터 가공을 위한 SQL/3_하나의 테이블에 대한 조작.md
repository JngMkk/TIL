

# 하나의 테이블에 대한 조작

```
프로그래밍 언어로서 SQL의 특징은 데이터를 집합으로 다룬다는 것이다.
이전까지는 테이블에 포함된 레코드 하나하나에 대한 조작 방법을 알아보았다.
하지만 데이터 분석 업무에서는 매우 많은 레코드에 처리를 적용하는데, 이를 하나하나 다루는 것은 비현실적이다.

따라서 대량의 데이터를 집계하고, 몇 가지 지표를 사용해 데이터 전체의 특징을 파악할 수 있어야 한다.
```

- 데이터 집약

```
SQL은 집약 함수라고 부르는 여러 가지 함수를 제공한다.
레코드의 수를 세주는 함수도 있고, 레코드에 저장된 값의 합계, 평균, 최대, 최소를 계산해주는 함수부터
통계 처리를 사용해 통계 지표를 출력해주는 함수도 있다.
SQL:2003에서 도입된 윈도 함수(분석 함수)를 사용하면,
기존의 SQL로는 하기 힘들었던 순서를 고려하는 처리, 여러 개의 레코드를 대상으로 하는 처리를 쉽게 할 수 있다.
```

- 데이터 가공

```
이번 장에서는 테이블 기반으로 데이터를 처리하는 방법을 알아본다.
만약 테이블의 형식이 집계에 적합하지 않은 경우, 어떻게 테이블을 가공해야 하는지도 알아본다.

이번 장에서 소개하는 과정을 밟지 않아도 데이터를 다룰 수 있게 데이터를 저장해두는 것이 좋다.
하지만 서비스를 구축하기 위해 설계된 업무 데이터를 사용하는 경우,
어쩔 수 없이 데이터를 가공해야 할 때가 있다.
따라서 데이터를 분석하기 쉬운 형태로 가공하는 방법도 반드시 알고 있어야 한다.
```



## 1. 그룹의 특징 잡기

> 집약 함수, GROUP BY 구문, 윈도 함수, OVER(... PARTITION BY ~) 구문

```
집약 함수란 여러 레코드를 기반으로 하나의 값을 리턴하는 함수.
예를 들어 ㄹ모든 레코드의 수를 리턴해주는 COUNT 함수, 값의 합계를 리턴해주는 SUM 함수 등
```

- 상품 평가 테이블

| user_id | prduct_id | score |
| ------- | --------- | ----- |
| U001    | A001      | 4.0   |
| U001    | A002      | 5.0   |
| U001    | A003      | 5.0   |
| U002    | A001      | 3.0   |
| U002    | A002      | 3.0   |
| U002    | A003      | 4.0   |
| U003    | A001      | 5.0   |
| U003    | A002      | 4.0   |
| U003    | A003      | 4.0   |



### 1-1. 테이블 전체의 특징량 계산하기

```
다음 코드는 자주 사용되는 집약 함수를 REVIEW 테이블에 적용하는 쿼리.
COUNT함수는 지정한 컬럼의 레코드 수를 리턴하는 함수.
컬럼 이름 앞에 DISTINCT 구문을 지정하면, 중복을 제외하고 수를 세어줌.
추가로 SUM 함수는 합계, AVG 함수는 평균을 구하는 함수.
따라서 SUM 함수와 AVG 함수는 컬럼의 자료형이 정수 또는 실수 등의 숫자 자료형이어야 함.

MAX 함수와 MIN 함수는 각각 최댓값과 최솟값을 구하는 함수.
따라서 대소 비교가 가능한 자료형(숫자, 문자열, 타임스탬프 등)에 적용할 수 있음.
```

- 집약 함수를 사용해서 테이블 전체의 특징량을 계산하는 쿼리

```SQL
SELECT
	COUNT(*) AS total_count
	, COUNT(DISTINCT user_id) AS user_count
	, COUNT(DISTINCT product_id) AS product_id
	, SUM(score) AS sum
	, TRUNC(AVG(score), 2) AS avg
	, MAX(score) AS max
	, MIN(score) AS min
FROM
	review
;
```

| total_count | user_count | product_count | sum  | avg  | max  | min  |
| ----------- | ---------- | ------------- | ---- | ---- | ---- | ---- |
| 9           | 3          | 3             | 37.0 | 4.11 | 5.0  | 3.0  |



### 1-2. 그루핑한 데이터의 특징량 계산하기

```
데이터를 조금 더 작게 분할하고 싶다면 GROUP BY 구문을 사용해 데이터를 분류할 키를 지정하고,
그러한 키를 기반으로 데이터를 집약한다.
```

- 사용자 기반으로 데이터를 분할하고 집약 함수를 적용하는 쿼리

```SQL
SELECT
	user_id
	, COUNT(*) AS total_count
	, COUNT(DISTINCT product_id) AS product_count
	, SUM(score) AS sum
	, TRUNC(AVG(score), 2) AS avg
	, MAX(score) AS max
	, MIN(score) AS min
FROM
	review
GROUP BY
	user_id
;
```

| user_id | total_count | product_count | sum  | avg  | max  | min  |
| ------- | ----------- | ------------- | ---- | ---- | ---- | ---- |
| U001    | 3           | 3             | 14.0 | 4.66 | 5.0  | 4.0  |
| U002    | 3           | 3             | 10.0 | 3.33 | 4.0  | 3.0  |
| U003    | 3           | 3             | 13.0 | 4.33 | 5.0  | 4.0  |

```
GROUP BY 구분을 사용한 쿼리에서는,
GROUP BY 구문에 지정한 컬럼 또는 집약 함수만 SELECT 구문의 컬럼으로 지정할 수 있다.
예를 들어 앞의 코드에서 SELECT 구문 내부에는 product_id 또는 score를 지정할 수 없다.

GROUP BY 구문을 사용한 쿼리에서는 GROUP BY 구문에 지정한 컬럼을 유니크 키로 새로운 테이블을 만들게 됨.
이 과정에서 GROUP BY 구문에 지정하지 않은 컬럼은 사라져 버린다.
따라서 집약 함수를 적용한 값과 집약 전의 값은 동시에 사용할 수 없는 것이다.
```



### 1-3. 집약 함수를 적용한 값과 집약 전의 값을 동시에 다루기

```
SQL:2003 이후에 정의된 윈도 함수가 지원되는 환경이라면,
윈도 함수를 사용해서 쉽고 효율적으로 집약 함수의 결과와 원래 값을 조합할 수 있다.
다음 코드는 윈도 함수를 사용해 개별 리뷰 점수와 사용자 평균 리뷰 점수의 차이를 구하는 예이다.
```

- 윈도 함수를 사용해 집약 함수의 결과와 원래 값을 동시에 다루는 쿼리

```SQL
SELECT
	user_id
	, product_id
	-- 개별 리뷰 점수
	, score
	-- 전체 평균 리뷰 점수
	, ROUND(AVG(score) OVER(), 2) AS avg_score
	-- 사용자의 평균 리뷰 점수
	, ROUND(AVG(score) OVER(PARTITION BY user_id), 2) AS user_avg_score
	-- 개별 리뷰 점수와 사용자 평균 리뷰 점수의 차이
	, ROUND(score - AVG(score) OVER(PARTITION BY user_id), 2) AS user_avg_score_diff
FROM
	review
;
```

![image](https://user-images.githubusercontent.com/87686562/148511040-c5dc0c1b-14ff-4454-aeaa-728be79249b9.png)

```
집약 함수로 윈도 함수를 사용하려면, 집약 함수 뒤에 OVER 구문을 붙이고 여기에 윈도 함수를 지정한다.
OVER 구문에 매개 변수를 지정하지 않으면 테이블 전체에 집약 함수를 적용한 값이 리턴된다.
매개 변수에 PARTITION BY <컬럼 이름>을 지정하면 해당 컬럼 값을 기반으로 그룹화하고 집약 함수를 적용한다.

앞의 코드 예를 보면 테이블 전체의 SCORE 평균값과 USER_ID들의 SCORE 평균값이
REVIEW 테이블의 원래 레코드를 건드리지 않고 추가된 것을 알 수 있다.
참고로 집약 함수의 결과와 원래 값을 조합해서 계산하므로
원래 SCORE와 USER_ID들의 SCORE 평균값 차이도 계산할 수 있다.
```



## 2. 그룹 내부의 순서

> 윈도 함수, OVER(... ORDER BY ~) 구문, OVER(... ROWS ~) 구문

```
SQL의 테이블은 기본적으로 순서라는 개념이 없다.
따라서 SQL로 순위를 작성하거나 시간 순서로 데이터를 다루려면 복잡한 방법을 사용해야했다.
하지만 윈도 함수가 등장하면서 SQL로 순서를 다루는 것이 굉장히 쉬워짐.

여기서는 인기 상품의 상품 ID, 카테고리, 스코어 정보를 가진 인기 상품 테이블을 샘플로
SQL을 사용한 순위 작성, 순서를 고려한 계산 실행 방법 등을 배워보자.
```

- 인기 상품 테이블


| product_id | category | score |
| ---------- | -------- | ----- |
| A001       | action   | 94    |
| A002       | action   | 81    |
| A003       | action   | 78    |
| A004       | action   | 64    |
| D001       | drama    | 90    |
| D002       | drama    | 82    |
| D003       | drama    | 78    |
| D004       | drama    | 58    |

