# 여러 개의 테이블 조작하기

- 업무 데이터를 사용하는 경우

```
업무 데이터는 RDB를 사용해 관리하는 경우가 많다.
RDB는 일반적으로 데이터를 정규화하고, 여러 테이블로 나누어 데이터를 관리한다.
따라서 데이터 분석을 할 때는 여러 테이블을 기반으로 우리가 원하는 정보를 추출해야 한다.

추가로 관계형 구조라는 이유가 아닌 다른 이유로 여러 개의 테이블에 데이터를 저장하는 경우도 있따.
데이터 분석을 하려면 이러한 테이블의 데이터를 하나로 합쳐야 하는 경우가 많다.
예를 들어 SNS 사이트를 생각해보면, '댓글', '좋아요', '팔로우'라는 각각의 테이블에 저장된 정보를 기반으로
'사용자가 어떤 행동을 하는가'를 분석하고 싶으면 이러한 테이블들을 하나로 합쳐서 다루어야 한다.
```

- 로그 데이터를 사용하는 경우

```
다양한 행동을 기록하는 하나의 거대한 로그 파일이 하나의 테이블에 저장된 경우에도,
여러 처리를 실행하려면 여러 개의 SELECT 구문을 조합하거나 자기 결합해서 레코드들을 비교해야 한다.
이처럼 테이블이 하나라도 여러 테이블을 다루는 것처럼 처리해야 하는 경우도 있다.
```



## 1. 여러 개의 테이블을 세로로 결합하기

> UNION ALL 구문

- 애플리케이션1의 사용자 마스터 테이블

  | user_id | name    | email               |
  | ------- | ------- | ------------------- |
  | U001    | Joongmo | joongmo@example.com |
  | U002    | Doeun   | doeun@example.com   |

- 애플리케이션2의 사용자 마스터 테이블

  | user_id | name    | phone         |
  | ------- | ------- | ------------- |
  | U001    | Hyewon  | 010-xxxx-xxxx |
  | U002    | Heejung | 011-xxxx-xxxx |

```
비슷한 구조를 가지는 테이블의 데이터를 일괄 처리하고 싶은 경우,
다음 코드처럼 UNION ALL 구문을 사용해 여러 개의 테이블을 세로로 결합하면 좋다.
결합할 때는 테이블의 컬럼이 완전히 일치해야 하므로,
한쪽 테이블에만 존재하는 컬럼은 phone 컬럼처럼 SELECT 구문으로 제외하거나 email 컬럼처럼 디폴트 값을 줘야 한다.

추가로 결합 후의 데이터가 어떤 테이블의 데이터였는지 식별할 수 있게 app_name이라는 열을 추가했다.
```

- UNION ALL 구문을 사용해 테이블을 세로로 결합하는 쿼리

```SQL
SELECT 'app1' AS app_name, user_id, name, email FROM app1_mst_users
UNION ALL
SELECT 'app2' AS app_name, user_id, name, NULL AS email FROM app2_mst_users;
```

![image](https://user-images.githubusercontent.com/87686562/148624340-9175eeca-fc8f-4503-9659-41a8b907f2d3.png)

```
UNION ALL 구문 대신 UNION DISTINCT(또는 UNION) 구문을 사용하면, 데이터의 중복을 제외한 결과를 얻을 수 있다.
다만 UNION ALL에 비해 거의 사용되지 않고 계산 비용이 많이 들어간다.
따라서 일단 UNION ALL 구문부터 확실하게 사용할 수 있게 연습하자.
```



## 2. 여러 개의 테이블을 가로로 정렬하기

> LEFT JOIN, 상관 서브 쿼리

```
여러 개의 테이블을 가로로 정렬하여 데이터를 비교하거나 값을 조합하고 싶은 경우

여러 개의 테이블을 가로 정렬할 때 가장 일반적인 방법은 JOIN을 사용하는 것이다.
다만 마스터 테이블에 JOIN을 사용하면 결합하지 못한 데이터가 사라지거나,
반대로 중복된 데이터가 발생할 수 있다.

아래 코드 예의 출력 결과는 테이블을 카테고리 ID로 단순하게 결합한 결과이다.
그런데 카테고리 마스터에 존재하는 book 카테고리가 결합하지 못해서 여러 개의 상품 데이터가 사라졌으며,
여러 개의 상품 ID가 부여된 DVD/CD 카테고리는 가격이 중복되어 출력되고 있다.
```

- 카테고리 마스터 테이블

| category_id | name |
| ----------- | ---- |
| 1           | dvd  |
| 2           | cd   |
| 3           | book |

- 카테고리별 매출 테이블

| category_id | sales  |
| ----------- | ------ |
| 1           | 850000 |
| 2           | 500000 |

- 카테고리별 상품 매출 순위 테이블

| category_id | rank | product_id | sales |
| ----------- | ---- | ---------- | ----- |
| 1           | 1    | D001       | 50000 |
| 1           | 2    | D002       | 20000 |
| 1           | 3    | D003       | 10000 |
| 2           | 1    | C001       | 30000 |
| 2           | 2    | C002       | 20000 |
| 2           | 3    | C003       | 10000 |

- 여러 개의 테이블을 결합해서 가로로 정렬하는 쿼리

```SQL
SELECT
	m.category_id
	, m.name
	, s.sales
	, r.product_id AS sale_product
FROM
	mst_categories AS m
	JOIN
		-- 카테고리별로 매출액 결합하기
		category_sales AS s
		ON m.category_id = s.category_id
	JOIN
		-- 카테고리별로 상품 결합하기
		product_sales_ranking AS r
		ON m.category_id = r.category_id
;
```

![image](https://user-images.githubusercontent.com/87686562/148625150-ca74ed30-4925-4122-a8af-67a7b600342c.png)

```
마스터 테이블의 행 수를 변경하지 않고 데이터를 가로 정렬하려면,
LEFT JOIN을 사용해 결합하지 못한 레코드를 유지한 상태로,
결합할 레코드가 반드시 1개 이하가 되게 하는 조건을 사용해야 한다.

아래 코드 예는 마스터 테이블의 행 수를 유지한 상태로 여러 개의 테이블을 가로로 정렬하는 쿼리이다.
LEFT JOIN을 사용해서 카테고리별 매출 테이블 등에 존재하지 않는 카테고리(book) 레코드를 유지한 상태로,
카테고리별 상품 매출 순위의 1위 상품만이라는 조건을 걸어 카테고리가 여러 행이 되지 않게 피한다.
```

- 마스터 테이블의 행 수를 변경하지 않고 여러 개의 테이블을 가로로 정렬하는 쿼리

```sql
SELECT
	m.category_id
	, m.name
	, s.sales
	, r.product_id AS top_sale_product
FROM
	mst_categories AS m
	-- LEFT JOIN을 사용해서 결합한 레코드를 남김
	LEFT JOIN
		-- 카테고리별 매출액 결합하기
		category_sales AS s
		ON m.category_id = s.category_id
	-- LEFT JOIN을 사용해서 결합하지 못한 레코드를 남김
	LEFT JOIN
		-- 카테고리별 최고 매출 상품 하나만 추출해서 결합하기
		product_sale_ranking AS r
		ON m.category_id = r.category_id
		AND r.rank = 1
;
```

![image](https://user-images.githubusercontent.com/87686562/148625482-a19c6a6f-6523-4174-bc59-a8894d2c2725.png)

---

```
SELECT 구문 내부에서 상관 서브 쿼리를 사용할 수 있는 미들웨어의 경우,
JOIN을 사용하지 않고 여러 테이블 값을 가로로 정렬할 수 있다.

아래 코드 예는 상관 서브 쿼리를 사용해서 이전의 코드 예와 같은 결과를 내는 코드를 만든 것이다.
JOIN을 사용하지 않아 원래 마스터 테이블의 행 수가 변할 걱정 자체가 없으므로,
테이블의 누락과 중복을 회피할 수 있다.

추가로 상관 서브쿼리의 경우 내부에서 ORDER BY 구문과 LIMIT 구문을 사용하면
사전 처리를 하지 않고도 데이터를 하나로 압축할 수 있다.
```

- 상관 서브쿼리로 여러 개의 테이블을 가로로 정렬하는 쿼리

```SQL
SELECT
	m.category_id
	, m.name
	-- 상관 서브쿼리를 사용해 카테고리별로 매출액 추출하기
	, (SELECT s.sales
      FROM category_sales AS s
      WHERE m.category_id = s.category_id
      ) AS sales
    -- 상관 서브쿼리를 사용해 카테고리별로 최고 매출 상품을 하나 추출하기(순위로 따로 압축하지 않아도 됨)
    , (SELECT r.product_id
      FROM product_sale_ranking AS r
      WHERE m.category_id = r.category_id
      ORDER BY sales DESC
      LIMIT 1
      ) AS top_sale_product
FROM
	mst_categories AS m
;
```

![image](https://user-images.githubusercontent.com/87686562/148626311-19c55b29-dd8d-45b7-a51a-778f86484c0c.png)



## 3. 조건 플래그를 0과 1로 표현하기

> CASE 식, SIGN 함수

```
여러 개의 테이블을 가로로 정렬하는 방법을 응용해서 마스터 테이블에 다양한 데이터를 집약하고,
마스터 테이블의 속성 조건을 0 또는 1이라는 플래그로 표현하는 방법을 알아보자.

예를 들어 아래 데이터 예처럼 신용카드 번호를 포함한 마스터 테이블에
구매로그 테이블을 결합해서 사용자들의 '신용카드 번호 등록 여부', '구매 이력 여부'라는
두 가지 조건을 0과 1로 표현하는 방법을 살펴보자.
```

- 신용카드 번호를 포함한 사용자 마스터 테이블

  | user_id | card_number         |
  | ------- | ------------------- |
  | U001    | 1234-xxxx-xxxx-xxxx |
  | U002    |                     |
  | U003    | 5678-xxxx-xxxx-xxxx |

- 구매 로그 테이블

  | purchase_id | user_id | amount | stamp               |
  | ----------- | ------- | ------ | ------------------- |
  | 10001       | U001    | 200    | 2017-01-30 10:00:00 |
  | 10002       | U001    | 500    | 2017-02-10 10:00:00 |
  | 10003       | U001    | 200    | 2017-02-12 10:00:00 |
  | 10004       | U002    | 800    | 2017-03-01 10:00:00 |
  | 10005       | U002    | 400    | 2017-03-02 10:00:00 |

```
사용자 마스터에 구매 로그를 결합할 때 LEFT JOIN을 사용한 뒤 사용자 ID로 GROUP BY하면,
사용자 마스터의 레코드 수를 그대로 유지한 상태로 구매 로그 정보를 결합할 수 있다.

이렇게 얻은 테이블을 기반으로 조건 플래그를 0과 1이라는 값으로 변환하는 방법은 크게 두 가지이다.
첫 번째는 CASE 식을 사용하는 방법, 두 번째는 SIGN 함수를 사용해 숫자를 0과 1로 변환하는 방법이다.

아래 코드 예는 CASE 식과 SIGN 함수로 신용카드 등록과 구매 이력 유무를 0과 1이라는 플래그로 나타내는 쿼리이다.
신용 카드 번호를 등록 하지 않은 경우 card_number 컬럼의 값이 NULL이므로,
CASE 식을 사용해서 NULL이 아닌 경우에는 1, NULL이라면 0으로 변환하게 했다.

추가로 구매 횟수를 COUNT 함수로 계산하면 COUNT의 결과는 0 이상의 정수가 된다.
따라서 SIGN 함수를 사용하면 구매 이력 유무를 0과 1이라는 값으로 변환할 수 있다.
```

- 신용 카드 등록과 구매 이력 유무를 0과 1이라는 플래그로 나타내는 쿼리

```SQL
SELECT
	m.user_id
	, m.card_number
	, COUNT(p.user_id) AS purchase_count
	-- 신용 카드 번호를 등록한 경우 1, 등록하지 않은 경우 0으로 표현하기
	, CASE WHEN m.card_number IS NOT NULL THEN 1 ELSE 0 END AS has_card
	-- 구매 이력이 있는 경우 1, 없는 경우 0으로 표현하기
	, SIGN(COUNT(p.user_id)) AS has_purchased
FROM
	mst_users_with_card_number AS m
	LEFT JOIN
		purchase_log AS p
		ON m.user_id = p.user_id
GROUP BY m.user_id, m.card_number
ORDER BY user_id
;
```

![image](https://user-images.githubusercontent.com/87686562/148627141-75ca73a9-0034-4a82-ac7f-36ac4bdac5bb.png)

